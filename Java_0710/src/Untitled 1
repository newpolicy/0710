
1.

5. 문자열의 동일성 여부를 비교해주는 equals(), equalsIgnoreCase()

 encoding == 문자를 컴퓨터에서 사용하기 위해 숫자로 변환 하는 것 // 숫자를 문자열로 변환하는 것은 decoding, 
 ==가장 유명한 인코딩이 ASCII 숫자 0->48 A->65 a-> 97 // 모든 인코딩 방식에서 ASCII 코드는 그대로 사용합니다.
 ==한글을 표현하는 방식은 일반적으로 2가지로 구분하는데 윈도우즈에서 사용하던 방식은 ms949(cp949)입니다. 이방식은 한글과 영문 그리고 숫자만 표현이 가능합니다
 웹에서는 예전에 ms949와 유사한 euc_kr을 사용했습니다. //유럽은 iso-8859-1이라는 인코딩을 표준으로 사용했는데 여기는 한글이 되지 않습니다.
 ==utf-8은 전세계 모든 문자를 표현할 수 있는 문자 인코딩 방식입니다. 이 인코딩 방식은 chrome, safari, linux, unix, mac-os의 표준 인코딩 방식입니다.
 문자열을 주고 받을때 인코딩 방식을 알아야하고 변환할 수 잇어야 합니다. 기존 시스템의 인코딩은 변경할 수 없기 때문에 기존시스템과 같이 사용하는 프로그램을 개발할 때는 
 인코딩이 다른경우에는 직접 인코딩과 디코딩 작업을 수행해야 합니다.
byte[] getBytes(String encType):문자열을 encType 바이트 배열로 변환하는 메소드
String(byte[] bytes, String encType): 바이트 배열을 encType의 문자열로 변환해서 생성합니다.ㅠ

java.lang.String.Builder== 변할 수 있는 문자열을 저장하는 클래스// 여분의 빈 공간을 확보하고 있다가 문자열에 변화가 오면 빈공간을 활용합니다.
==문자열을 다룰 때는 String과 StringBuilder를 적절하게 이용해야 합니다.//StringBuilder의 이전 버전으로 StringBuffer클래스가 있습니다.
1.생성자 -StringBUilder()
       -StringBUilder(int 초기 사이즈)
       -StringBUilder(String 문자열)
2.주요 메소드 -append(String str): 문자열 뒤에 추가
          -String toString(): 저장하고 있는 문자열을 String으로 리턴한다.
          
          String Builder sb = new StringBuilder();
          while(true){
                               한줄 다운로드 
                               다운로드 받은게 있으면 sb.append(다운로드 받은 문자열)
                               다운로드 받은게 없으면 중지
          }
          String content = sb.toString();
          sb = null;
          
          
Generics == 컴파일 할떄 자료형을 결정하지 말고 실행할때 자료형을 결정하는 기법이다, 미지정 자료형을 이용한다. -1.5버전부터 지원한다. 
            //동일한 알고리즘을 사용하는 메소드들을 매개변수나 리턴타입 때문에 별도로 만드는 것은 코드의 낭비
            //Generics에 적용하는 자료형은 참조형만 가능합니다. ex) int(value형)에 적용하고자 하는 경우 Integer라고 해야 한다.
            //Generics가 적용된 클래스는 자료구조 클래스이기 때문에 중요합니다.

Generics 를 지원하는 클래스의 인스턴스 만들기.

      Generics x                             Generics o
클래스 변수명 = new 생성자();  ->  클래스<실제 자료형> 변수명 = new 생성자<실제 자료형>(); //1.7부터는 실제자료형 생략하고 <>만 써도 된다.

 C-> JavaScript - Python - kotlin - Swift - R    //Generics o
                    -Ruby(Python의 단점을 보완)
                    
 C-> c++ - Java - C# - Objective - C (서버프로그래밍쪽에 사용)    // Generics x

enum == 값을 한정 짓기  위해서 final 변수들을 하나의 그룹으로 묶은 것   // 사용법은  enum 묶을 이름{ final 변수들의 이름을 나열 }으로 선언하고 
                                                                                                                             사용을 할 때는 -> 묶을이름.final변수이름으로 사용 
annotation == @로 시작하는 문자열로 메소드 위에 사용해서 자바코드를 호출하는 것 
           -@Override: 오버라이딩 된 메소드라는 것을 명시적으로 알려주고자 할때 사용한다, 이 이노테이션이 있는데 상위 클래스에 메소드가 존재하지 않으면 에러남
           -@Deprecated: 현재는 사용가능하지만 대체하는 메소드가 별도로 존재하므로 사용을 권장하지 않는 어노테이션
           -@SuppressWarning: 메소드 내부에서 경고가 발생하더라도 개의치 않고 수행하고 경고문을 없애달라는 어노테이션   

search(검색) == 데이터의 모임에서 특정 데이터의 존재여부나 위치를 찾는 것
          -순차검색: 데이터가 정렬되지 않았을때 맨 앞에서 부터 순서대로 데이터를 찾는 방식
          -제어검색: 데이터가 정렬되어 있을 때 데이터를 검색하는 방식
                  --binary search(이분 검색): 가운데 데이터와 비교해서 일치하면 찾은 것이고 작으면 왼쪽에가서 찾고 크면 오른쪽에 가서 찾는방식
                  --fibonacci search(피보나치 검색): 피보나치 수열을 이용해서 검색
                  --binary tree search(이진트리 검색): 데이터를 저장할 떄 작으면 왼쪽 크면 오른쪽에 배치해서 검색하는것.
                  --보감 검색: 검색위치를 계산해서 검색 
                  ex) data : 10 70 30 //정렬되지 않았으면 30을 찾으려면 3번 이동해서 찾는다. 10 30 70 정렬을 한 뒤 
                                                                               -이분검색: 30을 먼저 찾고 작으면 왼쪽 10, 크면 70 오른쪽

java.util.Arrays 클래스 == 모든 메소드가 static이기 때문에 instance를 생성할 필요가 없다.

static int binarySearch(Object [] ar, Object key) 
== ar배열에서 key의 위치를 검색해서 리턴하는 메소드, 못찾으면 음수를 리턴, 데이터가 정렬된 경우만 올바른 결과를 리턴한다.

static void sort(Object [] ar) == ar의 데이터를 정렬해주는 메소드, 정렬하려면 비교할수 있어야 한다.
                               == 비교하려면 반드시 Comparable 인터페이스를 implements 해서 compare메소드를 재정의 해야 한다.
                               == Comparable 인터페이스를 implements한 인스턴스를 같이 대입하면 Comparator 인터페이스의 메소드를 가지고 크기를 비교해서 정렬을 한다.
                               == 실제 구현을 할 때는 이 방법보다는 Comparator 인터페이스를 별로도 implements한 인스턴스를 만들어서 sort 메소드에 대입하는 경우가 많습니다.
                               == annonymous class: 익명 클래스 // 클래스나 인터페이스로부터 상속받는 클래스의 인스턴스를 1번만 사용하는 경우 클래스를
                                                           // 별도로 만들지 않고 인스턴스를 만드는 방법.
                                                            
배열의 정렬: java.util.Arrays 클래스의 sort 메소드를 이용 
-정렬(sort): 데이터를 순서대로 나열하는 것
          -오름차순(Ascending) == 작은 것에서 큰 것 순으로 나열
          -내림차순(Descending) == 큰 것에서 작은 것 순으로 나열
-정렬 알고리즘: 선택정렬, 버블정렬, 삽입정렬, quick정렬 등 삽입정렬까지는 반드시 숙지하고 알고리즘 시험을 봐야 하는 경우에는 quick정렬 까지 알아두자 근데 난 필요 없겠네
//정렬을 하려면 크기 비교가 가능해야 합니다- 일반 숫자데이터는 크기 비교가 가능 
                               - 날짜 데이터도 크기비교 가능//이유는 날짜값은 기준 시간으로 부터 지나온 시간 만큼 저장되기 때문
                               - 문자열은 각 문자를 코드로 변경해서 크기 비교가 가능.
                               - java에서는 이러한 크기 비교를 하는 메소드를 Comparable 인터페이스의 compareTo 라는 메소드를 이용해서 정의
                               - Comparable 인터페이스를 implements한 클래스의 인스턴스들은 크기 비교가 가능합니다.
                                 Comparable 인터페이스를 implements한 클래스의 인스턴스 배열은 Arrays.sort(배열명)을 이용하면 데이터를
                                                              오름차순으로 정렬해 줍니다.
                               - Comparable 인터페이스를 implements 하지 않은 클래스의 인스턴스 배열을 정렬하고자 할 때는 
                                 Arrays.sort(배열명, Comparator comparator)를 이용합니다.
                                 Comparator 인터페이스를 implements 클래스의 인스턴스를 대입해주면 인스턴스 안에 있는 compare 메소드를 
                                                             이용해서 크기 비교를 해서 정렬합니다.
                               
- 인터페이스나 클래스를 상속한 클래스의 인스턴스 만들기
1.클래스를 만들고 인스턴스를 만들기 // 인스턴스를 여러번 사용 할 떄
  class 클래스이름 extends 상위클래스이름 implements 인터페이스이름{
               필요한 메소드 재정의 
  }
    클래스이름 변수명 = new 클래스이름();

2. 클래스를 만들지 않고 인스턴스를 만들기- 인스턴스를 한번만 사용할 때
    인터페이스 or 상위클래스이름 변수명 = new 인스턴스나 상위클래스이름() {
               필요한 메소드 재정의
  }    
 -제너릭을 사용할 떄 매개변수가 object인 경우에는 반드시 원래의 자료형으로 형변환해서 사용해야 합니다.
 -Object 클래스는 치상위 클래스여서 모든 인스턴스의 주소를 전부 대입받을 수 있는대 사용을 할 때는 원래의 자료형으로 강제 형 변환해서 사용해야 합니다.  

String, String Builder // 반드시 기억할 것




          